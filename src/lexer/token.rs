use super::*;
#[derive(PartialEq)]
pub enum Identifier {
    NonRaw(IntKey),
    Raw(IntKey),
}

impl Identifier {
    pub fn new_non_raw<Q: ?Sized>(
        s: &Q,
        interner: &mut StringInterner,
    ) -> Identifier
    where
        Box<str>: std::borrow::Borrow<Q>,
        Q: std::hash::Hash + Eq,
        Q: AsRef<str>,
    {
        Identifier::NonRaw(interner.insert(s))
    }
    pub fn new_raw<Q: ?Sized>(
        s: &Q,
        interner: &mut StringInterner,
    ) -> Identifier
    where
        Box<str>: std::borrow::Borrow<Q>,
        Q: std::hash::Hash + Eq,
        Q: AsRef<str>,
    {
        Identifier::Raw(interner.insert(s))
    }
}

/// Token should take-up space at most a tag and a IntKey/usize
/// currently this is larger than 8 bytes, in the future, we shuold think up a way
/// to pack it into 8 bytes.
pub enum Token {
    /* Expression-operator symbols. */
    Eq,
    Lt,
    Le,
    EqEq,
    Ne,
    Ge,
    Gt,
    AndAnd,
    OrOr,
    Not,
    Tilde,
    BinOp(BinOpToken),
    BinOpEq(BinOpToken),

    /* Structural symbols */
    At,
    Dot,
    DotDot,
    DotDotDot,
    DotDotEq,
    Comma,
    Semi,
    Colon,
    ModSep,
    RArrow,
    LArrow,
    FatArrow,
    Pound,
    Dollar,
    Question,
    /// Used by proc macros for representing lifetimes, not generated by lexer right now.
    SingleQuote,
    /// An opening delimiter, eg. `{`
    OpenDelim(DelimToken),
    /// A closing delimiter, eg. `}`
    CloseDelim(DelimToken),

    Error,

    /* Literals */
    Literal(Lit),

    /* Name components */
    Ident(Identifier),
    Lifetime(Identifier),

    Shebang,

    Eof(usize),
}

pub enum DelimToken {
    Paren,
    Bracket,
    Brace,
    NoDelim,
}
pub enum StrStyle {
    Cooked,
    Raw(u16),
}

pub enum BinOpToken {
    Plus,
    Minus,
    Star,
    Slash,
    Percent,
    Caret,
    And,
    Or,
    Shl,
    Shr,
}

pub enum Lit {
    Byte(u8),
    Char(char),
    Num(IntKey),
    Str(IntKey),
    StrRaw(IntKey, u16),
}

#[derive(Clone, Copy)]
pub enum LitNum {
    I32(i32),
    U32(u32),
}
